plugins {
    id 'groovy'
    id 'maven-publish'
    id "ru.vyarus.quality" version "4.1.0"
    id "com.github.ben-manes.versions" version "0.28.0"
    id "name.remal.check-updates" version "1.1.3"
    id "com.cosminpolifronie.gradle.plantuml" version "1.6.0"
    id 'net.researchgate.release' version '2.8.1'
}

description = "A library that facilitates translation from one data format to another. Handles batches of messages and fields of objects."
group = "com.hpe.amce"

repositories {
    jcenter()
}

configurations.configureEach { configuration ->
    configuration.resolutionStrategy({ strategy ->
        strategy.eachDependency { DependencyResolveDetails dependency ->
            if (dependency.requested.group == 'org.codehaus.groovy') {
                dependency.useVersion "3.0.6"
            }
        }
    } as Action)
}

dependencies {
    implementation platform('org.apache.logging.log4j:log4j-bom:2.13.0')
    implementation 'org.codehaus.groovy:groovy'
    implementation "com.google.code.findbugs:jsr305:3.0.2"
    implementation 'org.apache.logging.log4j:log4j-core'
    implementation 'io.dropwizard.metrics:metrics-core:4.1.2'
    implementation 'javax.annotation:javax.annotation-api:1.3.2'
    testImplementation 'org.apache.logging.log4j:log4j-core::tests'
    testImplementation 'org.spockframework:spock-core:2.0-M2-groovy-3.0'
    testImplementation 'org.objenesis:objenesis:3.1'
    testImplementation 'cglib:cglib-nodep:3.3.0'
}

quality {
    // https://github.com/CodeNarc/CodeNarc/issues/426
    // But codenarc 1.5 seems to be incompatible with Groovy 3
    // codenarcVersion = '1.5'
    codenarc = false
}

wrapper {
    distributionType = Wrapper.DistributionType.ALL
}

task checkNoSnapshotDependencies {
    description "Check there are no SNAPSHOT dependencies if we're building non-SNAPSHOT version."
    group "verification"
    onlyIf { !(project.version =~ /SNAPSHOT/) }
    doLast {
        (buildscript.configurations + project.configurations).each { cfg ->
            cfg.dependencies.each { dependency ->
                if (dependency.version =~ /SNAPSHOT/) {
                    throw new GradleException("Build script dependency ${dependency.group}:${dependency.name}" +
                            " has SNAPSHOT version." +
                            " This is forbidden because we're supposed to build release version and" +
                            " there should be no SNAPSHOT dependencies.")
                }
            }
        }
    }
}
check.dependsOn checkNoSnapshotDependencies

dependencyUpdates {
    // Do not want to duplicate buildscript classpath for FQN to compile
    // com.github.benmanes.gradle.versions.reporter.result.Result
    outputFormatter = { result ->
        // com.github.benmanes.gradle.versions.reporter.result.DependencyOutdated
        result.outdated.dependencies.each { outdated ->
            project.logger.warn(
                    "There is outdated dependency:" +
                            " ${outdated.group}:${outdated.name}:${outdated.version}" +
                            " -> ${outdated.available.release ?: outdated.available.milestone}")
        }
        if (result.gradle.current.isUpdateAvailable && result.gradle.current > result.gradle.running) {
            project.logger.warn(
                    "Gradle is outdated:" +
                            " ${result.gradle.running.version}" +
                            " -> ${result.gradle.current.version}")
        }
        // com.github.benmanes.gradle.versions.reporter.result.DependencyUnresolved
        result.unresolved.dependencies.each { unresolved ->
            project.logger.warn(
                    "Could not determine latest version for" +
                            " ${unresolved.group}:${unresolved.name}:${unresolved.version}" +
                            " because ${unresolved.reason}")
        }
    }
    resolutionStrategy { ResolutionStrategy strategy ->
        strategy.componentSelection { rules ->
            rules.all { ComponentSelection selection ->
                if (selection.candidate.version =~ /redhat/ || ['alpha', 'beta', 'rc', 'cr', 'm', 'preview'].
                        any { qualifier -> selection.candidate.version =~ /(?i)\b${qualifier}\d*\b/ }) {
                    selection.reject('Release candidate')
                }
            }
        }
    }
}
check.dependsOn dependencyUpdates

groovydoc {
    noTimestamp = true
    noVersionStamp = true
}

task groovydocJar(type: Jar, dependsOn: groovydoc) {
    archiveClassifier.set('javadoc')
    from groovydoc.destinationDir
}

task sourcesJar(type: Jar) {
    archiveClassifier.set('sources')
    from sourceSets.main.allSource
}

artifacts {
    archives sourcesJar
    archives groovydocJar
}

publishing {
    publications {
        maven(MavenPublication) {
            from components.java
            artifact sourcesJar
            artifact groovydocJar
            pom {
                licenses {
                    license {
                        name = 'The Apache License, Version 2.0'
                        url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                    }
                }
            }
            versionMapping {
                usage('java-api') {
                    fromResolutionOf('runtimeClasspath')
                }
                usage('java-runtime') {
                    fromResolutionResult()
                }
            }
        }
    }
}

test {
    useJUnitPlatform()
}

plantUml {
    render input: 'src/docs/diagrams/*.puml', output: 'src/docs/diagrams/', format: 'svg', withMetadata: false
}

release {
    git {
        pushToRemote = false
    }
}

project.extensions.extraProperties['release.useAutomaticVersion'] = true

tasks.named('build').configure { build ->
    build.dependsOn tasks.named("plantUml")
}

defaultTasks = [publishToMavenLocal.name]
